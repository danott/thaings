#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../thaings'
require 'open3'
require 'timeout'
require 'uri'

# Load .env file
env_file = THAINGS_ROOT / '.env'
if env_file.exist?
  env_file.readlines.each do |line|
    line = line.strip
    next if line.empty? || line.start_with?('#')
    key, value = line.split('=', 2)
    ENV[key] = value if key && value
  end
end

DAEMON_LOG = THAINGS_ROOT / 'log' / 'daemon.log'

# Finds processable to-dos
class FindsProcessableToDos
  attr_reader :store

  def initialize(store: ToDoStore.new)
    @store = store
  end

  def call
    store.all_ids
      .map { |id| store.find(id) }
      .compact
      .select(&:processable?)
      .sort_by { |t| t.received_at || '' }
  end
end

# Builds a prompt from to-do properties
class BuildsPrompt
  attr_reader :to_do

  def initialize(to_do)
    @to_do = to_do
  end

  def call
    parts = []
    parts << to_do.title if to_do.title
    parts << "\n\n#{to_do.notes}" unless to_do.notes.empty?
    parts << "\n\nChecklist:\n#{to_do.checklist}" if checklist_present?
    parts.join
  end

  private

  def checklist_present?
    to_do.checklist.is_a?(String) && !to_do.checklist.empty?
  end
end

# Asks Claude to respond to a prompt
#
# Uses two safeguards:
# - --max-turns: graceful exit at turn boundaries (prevents runaway loops)
# - Timeout: hard ceiling on wall-clock time (prevents hung processes)
#
class AsksClaude
  INSTRUCTIONS_FILE = THAINGS_ROOT / 'to-do-instructions.txt'
  ALLOWED_TOOLS = %w[WebSearch WebFetch].freeze
  MAX_TURNS = 10 # Enough for moderate research; may need adjustment based on real-world usage
  TIMEOUT_SECONDS = 300 # 5 minutes

  attr_reader :to_do_dir

  def initialize(to_do_dir)
    @to_do_dir = to_do_dir
  end

  def call(prompt)
    stdout, stderr, process = run(prompt)

    if process.success?
      stdout
    else
      "Error: Claude execution failed.\n#{stderr}"
    end
  rescue Timeout::Error
    "Error: Claude timed out after #{TIMEOUT_SECONDS} seconds."
  end

  private

  def run(prompt)
    Timeout.timeout(TIMEOUT_SECONDS) do
      stdout, stderr, status = Open3.capture3(
        '/opt/homebrew/bin/claude',
        '--continue',
        '--print',
        '--max-turns', MAX_TURNS.to_s,
        '--append-system-prompt-file', INSTRUCTIONS_FILE.to_s,
        '--allowedTools', ALLOWED_TOOLS.join(','),
        '-p', prompt,
        chdir: to_do_dir.to_s
      )
      [stdout.force_encoding('UTF-8'), stderr.force_encoding('UTF-8'), status]
    end
  end
end

# Updates Things app via URL scheme
#
# Knows about Things-specific concepts like tags for workflow states.
#
class UpdatesThings
  TAG_WORKING = 'Working'
  TAG_READY = 'Ready'
  THAINGS_TAGS = [TAG_WORKING, TAG_READY].freeze

  class UpdateFailed < StandardError; end

  def append_note(id, text)
    note = "\n\n---\n\n#{text}\n\n***\n\n"

    open_url(id, 'append-notes' => note)
  end

  def set_working_tag(id, current_tags)
    set_workflow_tag(id, current_tags, TAG_WORKING)
  end

  def set_ready_tag(id, current_tags)
    set_workflow_tag(id, current_tags, TAG_READY)
  end

  private

  def set_workflow_tag(id, current_tags, new_tag)
    tags = without_thaings_tags(current_tags) + [new_tag]
    open_url(id, 'tags' => tags.join(','))
  end

  def without_thaings_tags(tags)
    tags.reject { |t| THAINGS_TAGS.include?(t) }
  end

  def open_url(id, params)
    query = params.merge('id' => id, 'auth-token' => auth_token)
      .map { |k, v| "#{k}=#{URI.encode_www_form_component(v).gsub('+', '%20')}" }
      .join('&')

    url = "things:///update?#{query}"
    return if system('open', '-g', url)

    raise UpdateFailed, "Failed to open Things URL: #{url[0, 50]}..."
  end

  def auth_token
    ENV.fetch('THINGS_AUTH_TOKEN') { raise 'Missing THINGS_AUTH_TOKEN in ~/.thaings/.env' }
  end
end

# Acquires an exclusive lock on a to-do for processing
#
# Usage:
#   LocksToDoForProcessing.new(to_do).call { do_work }
#   # => returns block result, or false if already locked
#
class LocksToDoForProcessing
  attr_reader :to_do

  def initialize(to_do)
    @to_do = to_do
  end

  def call
    File.open(lock_path, File::RDWR | File::CREAT) do |f|
      return false unless f.flock(File::LOCK_EX | File::LOCK_NB)

      yield
    end
  end

  private

  def lock_path
    to_do.dir / '.lock'
  end
end

# Processes a single to-do through Claude
class ProcessesToDo
  attr_reader :to_do, :store, :things, :daemon_log, :to_do_log

  def initialize(to_do, store: ToDoStore.new, things: UpdatesThings.new, daemon_log: Log.new(DAEMON_LOG))
    @to_do = to_do
    @store = store
    @things = things
    @daemon_log = daemon_log
    @to_do_log = Log.new(to_do.log_file)
  end

  def call
    LocksToDoForProcessing.new(to_do).call do
      working_to_do = start_processing
      response = ask_claude(working_to_do)
      finish_processing(working_to_do, response)
    end || daemon_log.write('skip', "#{to_do.id} - already locked")
  end

  private

  def start_processing
    working_to_do = store.mark_working(to_do)
    store.save(working_to_do)
    things.set_working_tag(to_do.id, to_do.tags)

    daemon_log.write('start', "#{to_do.id} - processing")
    to_do_log.write('daemon', 'Started processing')

    working_to_do
  end

  def ask_claude(current_to_do)
    prompt = BuildsPrompt.new(current_to_do).call

    if prompt.strip.empty?
      to_do_log.write('daemon', 'Skipped: no content to process')
      return 'Nothing to process - add a title or notes and try again.'
    end

    to_do_log.write('daemon', "Prompt: #{prompt.lines.first&.strip}")
    AsksClaude.new(current_to_do.dir).call(prompt)
  end

  def finish_processing(working_to_do, response)
    review_to_do = store.mark_review(working_to_do)
    store.save(review_to_do)

    things.append_note(to_do.id, response)
    things.set_ready_tag(to_do.id, to_do.tags)

    to_do_log.write('daemon', 'Completed')
    daemon_log.write('done', "#{to_do.id}")
  end
end

# Entry point: wakes, finds processable to-dos, processes them
class RespondsToThingsToDo
  attr_reader :log

  def initialize(log: Log.new(DAEMON_LOG))
    @log = log
  end

  def call
    log.write('wake', 'Daemon triggered')

    to_dos = FindsProcessableToDos.new.call

    if to_dos.empty?
      log.write('idle', 'No to-dos to process')
      return
    end

    log.write('found', "#{to_dos.length} to-do(s) to process")

    to_dos.each { |to_do| ProcessesToDo.new(to_do).call }

    log.write('exit', 'Daemon finished')
  end
end

RespondsToThingsToDo.new.call
